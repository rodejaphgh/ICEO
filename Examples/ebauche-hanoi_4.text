" WorldMorph currentWorld "PolygonMorph subclass: #ICEOMorph	instanceVariableNames: ''	classVariableNames: ''	package: 'Morphic-Base-Basic'.	ICEOMorph compile: 'handlesMouseDown: anEvent       ^ true'.ICEOMorph compile: 'mouseDown: anEvent    anEvent redButtonPressed        ifTrue: [((Smalltalk at: #Step) == 0) ifTrue: [(monde get: #Hanoi)  go]].      anEvent yellowButtonPressed     ifTrue: [(monde get: #Hanoi) fin. ICEO reset. ''See you  !'' crTrace].self changed'.iceo definition: #jeu.iceo definitionSituation: #piquet.   iceo definitionAttribut: #disque de: jeu cardinalite: 8.Smalltalk at: #delay put: 1000.  "ms"jeu compile: 'getDisques 	^(monde get: #Hanoi) getEtresAttributs: #disque'.iceo definitionQualite: #sous situation: absolu.(absolu get: #sous) referenceEssence: (jeu getEssenceAttribut: #disque).(jeu getEssenceAttribut: #disque) peutEtre: (absolu get: #sous).iceo definitionQualite: #sur situation: absolu.(absolu get: #sur) referenceEssence: (jeu getEssenceAttribut: #disque).(jeu getEssenceAttribut: #disque) peutEtre: (absolu get: #sur).iceo definitionQualite: #déplacé situation: piquet.(jeu getEssenceAttribut: #disque) peutEtre: (piquet get: #déplacé).iceo definitionQualite: #dernier situation: absolu.(jeu getEssenceAttribut: #disque) peutEtre: (absolu get: #dernier).iceo definitionQualite: #immobilisé situation: absolu.(jeu getEssenceAttribut: #disque) peutEtre: (absolu get: #immobilisé).jeu compile: 'allezAuxStartingBlocks	self getDisques  do: [:each |  (each getEtat: #comportement) getProcess resume].	self construirePiste.	(Smalltalk at: #Piste)  openInWorld '.		" le disque le plus petit commence "jeu compile: 'go	(((self getDisques  sorted: [:a :b |   a getTaille <  b getTaille]) at: 1)  getEtat: #comportement)  getSemaphore  signal'.	jeu compile: 'fin	self getDisques  do: [:each |  (each getEtat: #comportement) getProcess terminate].	(Smalltalk at: #Piste) delete'.iceo definitionQualiteEssentielle: #comportement pour: (jeu getEssenceAttribut: #disque) effectivite: #permanente.( (jeu getEssenceAttribut: #disque) getQualite: #comportement) addInstVarNamed: #sem.( (jeu getEssenceAttribut: #disque) getQualite: #comportement) compile: 'setSemaphore: unSemaphore sem := unSemaphore'. ( (jeu getEssenceAttribut: #disque) getQualite: #comportement) compile: 'getSemaphore ^sem'. ( (jeu getEssenceAttribut: #disque) getQualite: #comportement) addInstVarNamed: #process.( (jeu getEssenceAttribut: #disque) getQualite: #comportement) compile: 'setProcess: unProcess process := unProcess'. ( (jeu getEssenceAttribut: #disque) getQualite: #comportement) compile: 'getProcess ^process'." pour l'animation "(jeu getEssenceAttribut: #disque) addInstVarNamed: #morph.(jeu getEssenceAttribut: #disque)  compile: 'setMorph: uneMorph morph := uneMorph'. (jeu getEssenceAttribut: #disque)  compile: 'getMorph ^ morph'. (jeu getEssenceAttribut: #disque) compile: 'getTaille	^(((monde get: #Hanoi) getEtresAttributs: #disque) size - (self getNom  withoutPrefix: #disque_) asInteger) * 2'.	(jeu getEssenceAttribut: #disque) compile: 'getPiquet	^(monde getSituations: #piquet) detect: [:each |  each getElements includes: self]'.	 (jeu getEssenceAttribut: #disque) compile: 'peutSeDeplacer	| disques |	(((self getEtat: #sous) notNil or: [(self getEtat: #dernier) notNil]) or: [(self getEtat: #immobilisé) notNil]) ifTrue: [^false].  	(monde getSituations: #piquet) do: 		[:p | disques :=  p getElements select: [:each |    each getEssence getNom == #disque]. 			(disques size == 0 or: [disques last getTaille >  self getTaille])  ifTrue: [^true]].	^false '.	jeu  compile: 'construirePiste| piste m p1 p2 p3 p4 x g w e h font z g1 g2 g3 g4 mp1 mp2 mp3 mp4 |w := 10.z := (monde get: #Hanoi) getDisques first getTaille * w.g := 100 + (z * 4).g1 := 100 + (z / 2).g2 := 100 + (3 * z / 2).g3 := 100 + (5 * z / 2).g4 := 100 + (7 * z / 2).piste := (ICEOMorph		vertices: {100@800. g@800. g@801. 100@801}		color: (Color white alpha: 0.0)		borderWidth: 1		borderColor: Color black).mp1  := (ICEOMorph		vertices: {g1@800. g1@800. g1@500. g1@500}		color: (Color white alpha: 1)		borderWidth: 1		borderColor: Color black).piste addMorph: mp1.mp2  := (ICEOMorph		vertices: {g2@800. g2@800. g2@500. g2@500}		color: (Color white alpha: 1)		borderWidth: 1		borderColor: Color black).piste addMorph: mp2.mp3  := (ICEOMorph		vertices: {g3@800. g3@800. g3@500. g3@500}		color: (Color white alpha: 1)		borderWidth: 1		borderColor: Color black).piste addMorph: mp3.mp3  := (ICEOMorph		vertices: {g4@800. g4@800. g4@500. g4@500}		color: (Color white alpha: 1)		borderWidth: 1		borderColor: Color black).piste addMorph: mp3.font := LogicalFont familyName: StandardFonts defaultFont familyName pointSize: 25.Smalltalk at: #StepMorph put: (((StringMorph contents: ''0'' font: font emphasis: TextEmphasis bold) position: (100@300)) color: Color black).piste addMorph: (Smalltalk at: #StepMorph).h := 16.e :=5.x := 0.	(monde get: #Hanoi) getDisques do: [:d |   		p1 := (100 + (w * x)) @  (800 - (h + e * x + e)) .       	p2 := (100 + (w * x) + (d getTaille * w)) @  (800 - (h + e * x + e)) . 	p3 := (100 + (w * x) + (d getTaille * w)) @  (800 - (h + e * x + h + e)) .	p4 := (100 + (w * x)) @  (800 - (h + e * x + h + e)) .	Transcript show: ''ex1 = ''	, (100 + (w * x) + (d getTaille * w)) asString.	x := x+1.	m :=  (PolygonMorph			vertices: {p1. p2. p3. p4}			color: Color random			borderWidth: 1			borderColor: Color black).		piste addMorph: m.		d setMorph: m].Smalltalk at: #Piste put: piste'. "------------------------------------------"(jeu getEssenceAttribut: #disque) compile: 'jeVaisSurPiquet: unPiquet	| d dd p x y w h e g1 g2 g3  g4 z  |	w := 10.	h := 16.	e :=5.	z := (monde get: #Hanoi) getDisques first getTaille * w.	g1 := 100 + (z / 2).	g2 := 100 + (3 * z / 2).	g3 := 100 + (5 * z / 2).	g4 := 100 + (7 * z / 2).	p := self getPiquet.	(self getNom asString , '' : '' , p getNom , '' ---> '' , unPiquet getNom) crTrace.		"disques sur mon piquet "	d := p getElements select: [ :each |		     each getEssence getNom == #disque ]. 	"disques sur  piquet cible "	dd := unPiquet getElements select: [ :each |		      each getEssence getNom == #disque ]. 	(dd size == 0 or: [ dd last getTaille > self getTaille ]) ifTrue: [ "je quitte mon piquet "		p removeEtre: self.		d := p getElements select: [ :each |			     each getEssence getNom == #disque ]. "disques restant sur mon piquet"		d size ~~ 0 ifTrue: [			d last removeEtatDeNom: #sous.			self removeEtatDeNom: #sur ].		(self getEtat: #déplacé) isNil ifFalse: [self removeEtatDeNom: #déplacé].		(self affecteEtat: (piquet get: #déplacé) dansSituation: p)].	dd size ~~ 0 ifTrue: [		(dd last affecteEtat: (absolu get: #sous) dansSituation: monde)			attributionEtre: self.		(self affecteEtat: (absolu get: #sur) dansSituation: monde)			attributionEtre: dd last ].	unPiquet introductionEtre: self.			unPiquet getNom == #piquet_0 ifTrue: [		x := g1 - (self getTaille * w / 2)].		unPiquet getNom == #piquet_1 ifTrue: [		x := g2 - (self getTaille * w / 2)].		unPiquet getNom == #piquet_2 ifTrue: [		x := g3 - (self getTaille * w / 2)].		unPiquet getNom == #piquet_3 ifTrue: [		x := g4 - (self getTaille * w / 2)].	y := 800  - ((dd size +1) * (h + e)) .		self getMorph position: x @ y .	Semaphore new		waitTimeoutMilliseconds: (Smalltalk at: #delay)		onCompletion: [  ]		onTimeout: [  ] '.(jeu getEssenceAttribut: #disque) compile: 'jePrendsLeRelais	| disques disks choix step previous |		" choix du piquet cible, sans retour arrière possible  "		choix := nil.		"Dans le cas d''un nombre de disques égal à 8"	(Smalltalk at: #Step) ==  25 ifTrue: [(monde getSituations:  #piquet) detect:  [:p | ( p getElements select: [ :each | each getEssence getNom == #disque ]) size > 3]   ifFound: [:e | choix := e]].		" si je me suis déjà déplacé, sur quel piquet étais-je ? "	(self getEtat: #déplacé) notNil ifTrue: [previous := (self getEtat: #déplacé) getSituationDefinition].	" si un piquet libre, y aller, sauf si ce faisant je libère un piquet "	choix isNil ifTrue: [ 		(monde getSituations:  #piquet) reverseDo: [ :unPiquet |			((unPiquet ~~ self getPiquet and: [ unPiquet ~~ previous]) and: [(self getEtat: #sur) notNil or: [self getNom == #disque_0]])  ifTrue: [				disks := unPiquet getElements select: [ :each | each getEssence getNom == #disque ].						disks size == 0 ifTrue: [choix isNil ifTrue: [choix := unPiquet]]] ]].			choix isNil ifTrue: [ 		" sinon, trouver un piquet portant un disque plus grand" 		(monde getSituations:  #piquet) do: [ :unPiquet |			(unPiquet ~~ self getPiquet and: [ unPiquet ~~ previous ]) ifTrue: [  				disques := unPiquet getElements select: [ :each | each getEssence getNom == #disque ].				disques detect: [ :d | ((d getEtat: #sous) isNil)  and: [d getTaille > self getTaille ]] ifFound: [:e | choix isNil ifTrue: [choix := e getPiquet]]] ] ].					step := (Smalltalk at: #Step) + 1.	Smalltalk at: #Step put: step.	(Smalltalk at: #StepMorph) contents: step asString. 	self jeVaisSurPiquet: choix. 		(monde get: #Hanoi) getDisques  do: [ :d | d removeEtatDeNom: #dernier ].	self affecteEtat: (absolu get: #dernier) dansSituation: monde  '.			"-------------------------------------------"			iceo soit: #Hanoi essence: jeu.iceo soit: #piquet_0 situationGenerique: piquet.iceo soit: #piquet_1 situationGenerique: piquet.iceo soit: #piquet_2 situationGenerique: piquet.iceo soit: #piquet_3 situationGenerique: piquet.	" empilement intial des disques sur le piquet 0"(monde get: #Hanoi) getDisques  do: 			[:d | (monde getSituation:  #piquet_0)  introductionEtre: d].(Interval from: 1 to: ((monde get: #Hanoi) getDisques size -1))  do:  [:i | 				((monde get: #Hanoi) getDisques at:  i)  affecteEtat: (absolu get: #sous) dansSituation:  monde. 				(((monde get: #Hanoi) getDisques at:  i)  getEtat: #sous) attributionEtre:  ((monde get: #Hanoi) getDisques at:  i+1).				((monde get: #Hanoi) getDisques at:  i+1)  affecteEtat: (absolu get: #sur) dansSituation:  monde. 				(((monde get: #Hanoi) getDisques at:  i+1)  getEtat: #sur) attributionEtre:  ((monde get: #Hanoi) getDisques at:  i)].			" définition du rôle de chaque joueur "  (monde get: #Hanoi) getEtres do: [ :each |	| started |	started := false.	(each getEtat: #comportement) setSemaphore: Semaphore new.	(each getEtat: #comportement) setProcess: ([ :h :d |		 | s x c |		 s isNil ifTrue: [ s := false ].		 [ true ] whileTrue: [			 s ifFalse: [				 (d getNom , ' is ready') crTrace.				 s := true.				 (d getEtat: #comportement) getSemaphore wait ].			 d jePrendsLeRelais.			 "qui peut maintenant prendre le relais ? "						 c := (h getEtres select: [ :disque |				       disque getTaille <= h getEtres size and: [					       disque peutSeDeplacer ] ]) sorted: [ :a :b |				      a getTaille > b getTaille ].						 c size = 0 ifTrue: [				 h getEtres do: [ :disque |					 disque getTaille <= h getEtres size ifTrue: [						 (disque getEtat: #immobilisé) isNil ifTrue: [							 disque								 affecteEtat: (absolu get: #immobilisé)								 dansSituation: monde ] ] ].				 c := (h getEtres select: [ :disque |					       disque getTaille > h getEtres size and: [						       disque peutSeDeplacer ] ]) sorted: [ :a :b |					      a getTaille > b getTaille ].								 c size = 0 ifTrue: [					 h getEtres do: [ :disque |						 disque getTaille <= h getEtres size ifTrue: [							 disque removeEtatDeNom: #immobilisé] ].						 c := (h getEtres select: [ :disque | 						       disque getTaille <= h getEtres size and: [							       disque peutSeDeplacer ] ]) sorted: [ :a :b |						      a getTaille >  b getTaille ] ] ].			c size > 0 ifTrue: [ x := c at: 1.			 (x getEtat: #comportement) getSemaphore signal].			 (d getEtat: #comportement) getSemaphore wait ] ] newProcessWith:  (Array with: (monde get: #Hanoi) with: each)) ].												" ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- "									Transcript clear.Smalltalk at: #Step put: 0.(monde get: #Hanoi)  allezAuxStartingBlocks.