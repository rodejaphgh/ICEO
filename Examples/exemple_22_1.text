" WorldMorph currentWorld ""ThreadSafeTranscript"PolygonMorph subclass: #ICEOMorph	instanceVariableNames: ''	classVariableNames: ''	package: 'Morphic-Base-Basic'.	ICEOMorph compile: 'handlesMouseDown: anEvent         ^ true'.ICEOMorph compile: 'mouseDown: anEvent    anEvent redButtonPressed        ifTrue: [((Smalltalk at: #Step) == 0) ifTrue: [(monde get: #Hanoi)  go] ifFalse: [Smalltalk at: #go put: true]].      anEvent yellowButtonPressed     ifTrue: [(monde get: #Hanoi) fin. ICEO reset. ''See you  !'' crTrace].self changed'.iceo definition: #jeu.iceo definitionSituation: #piquet. iceo soit: #piquet_0 situationGenerique: piquet.iceo soit: #piquet_1 situationGenerique: piquet.iceo soit: #piquet_2 situationGenerique: piquet.iceo soit: #piquet_3 situationGenerique: piquet.   iceo definitionAttribut: #disque de: jeu cardinalite: 10..Smalltalk at: #delay put: 0.  "ms"jeu compile: 'getDisques 	^(monde get: #Hanoi) getEtresAttributs: #disque'.	jeu compile: 'getNbDisques	^self getDisques size'.iceo definitionQualite: #sous situation: absolu.(absolu get: #sous) referenceEssence: (jeu getEssenceAttribut: #disque).(jeu getEssenceAttribut: #disque) peutEtre: (absolu get: #sous).iceo definitionQualite: #sur situation: absolu.(absolu get: #sur) referenceEssence: (jeu getEssenceAttribut: #disque).(jeu getEssenceAttribut: #disque) peutEtre: (absolu get: #sur).iceo definitionQualite: #déplacé situation: piquet.(jeu getEssenceAttribut: #disque) peutEtre: (piquet get: #déplacé).iceo definitionQualite: #dernier situation: absolu.(jeu getEssenceAttribut: #disque) peutEtre: (absolu get: #dernier).iceo definitionQualite: #prioritaire situation: absolu.(jeu getEssenceAttribut: #disque) peutEtre: (absolu get: #prioritaire). jeu compile: 'allezAuxStartingBlocks	self getDisques  do: [:each |  (each getEtat: #comportement) getProcess resume].	self construirePiste.	(Smalltalk at: #Piste)  openInWorld '.		" le disque le plus petit commence "jeu compile: 'go	(((self getDisques  sorted: [:a :b |   a getTaille <  b getTaille]) at: 1)  getEtat: #comportement)  getSemaphore  signal'.	jeu compile: 'fin	self getDisques  do: [:each |  (each getEtat: #comportement) getProcess terminate].	(Smalltalk at: #Piste) delete'.iceo definitionQualiteEssentielle: #comportement pour: (jeu getEssenceAttribut: #disque) effectivite: #permanente.( (jeu getEssenceAttribut: #disque) getQualite: #comportement) addInstVarNamed: #sem.( (jeu getEssenceAttribut: #disque) getQualite: #comportement) compile: 'setSemaphore: unSemaphore sem := unSemaphore'. ( (jeu getEssenceAttribut: #disque) getQualite: #comportement) compile: 'getSemaphore ^sem'. ( (jeu getEssenceAttribut: #disque) getQualite: #comportement) addInstVarNamed: #process.( (jeu getEssenceAttribut: #disque) getQualite: #comportement) compile: 'setProcess: unProcess process := unProcess'. ( (jeu getEssenceAttribut: #disque) getQualite: #comportement) compile: 'getProcess ^process'." pour l'animation "(jeu getEssenceAttribut: #disque) addInstVarNamed: #morph.(jeu getEssenceAttribut: #disque)  compile: 'setMorph: uneMorph morph := uneMorph'. (jeu getEssenceAttribut: #disque)  compile: 'getMorph ^ morph'. (jeu getEssenceAttribut: #disque) compile: 'getTaille	^(((monde get: #Hanoi) getEtresAttributs: #disque) size - (self getNom  withoutPrefix: #disque_) asInteger) * 2'.	(jeu getEssenceAttribut: #disque) compile: 'getPiquet	^(monde getSituations: #piquet) detect: [:each |  each getElements includes: self]'.	(absolu getSituationGenerique: #piquet) compile: 'getTop	| disques top |		disques :=  self getElements select: [:each |    each getEssence getNom == #disque]. 		disques size > 0 ifTrue: [top := disques last].		^top'.		(absolu getSituationGenerique: #piquet) compile: 'getNbDisques		^(self getElements select: [:each |    each getEssence getNom == #disque]) size'.	jeu  compile: 'construirePiste| piste m p1 p2 p3 p4 x g w e h font z g1 g2 g3 g4 mp1 mp2 mp3 mp4 |w := 10.z := (monde get: #Hanoi) getDisques first getTaille * w.g := 100 + (z * 4).g1 := 100 + (z / 2).g2 := 100 + (3 * z / 2).g3 := 100 + (5 * z / 2).g4 := 100 + (7 * z / 2).piste := (ICEOMorph		vertices: {100@800. g@800. g@801. 100@801}		color: (Color white alpha: 0.0)		borderWidth: 1		borderColor: Color black).mp1  := (ICEOMorph		vertices: {g1@800. g1@800. g1@500. g1@500}		color: (Color white alpha: 1)		borderWidth: 1		borderColor: Color black).piste addMorph: mp1.mp2  := (ICEOMorph		vertices: {g2@800. g2@800. g2@500. g2@500}		color: (Color white alpha: 1)		borderWidth: 1		borderColor: Color black).piste addMorph: mp2.mp3  := (ICEOMorph		vertices: {g3@800. g3@800. g3@500. g3@500}		color: (Color white alpha: 1)		borderWidth: 1		borderColor: Color black).piste addMorph: mp3.mp4  := (ICEOMorph		vertices: {g4@800. g4@800. g4@500. g4@500}		color: (Color white alpha: 1)		borderWidth: 1		borderColor: Color black).piste addMorph: mp4.font := LogicalFont familyName: StandardFonts defaultFont familyName pointSize: 25.Smalltalk at: #StepMorph put: (((StringMorph contents: ''0'' font: font emphasis: TextEmphasis bold) position: (100@300)) color: Color black).piste addMorph: (Smalltalk at: #StepMorph).h := 16.e :=5.x := 0.	(monde get: #Hanoi) getDisques do: [:d |   		p1 := (100 + (w * x)) @  (800 - (h + e * x + e)) .       	p2 := (100 + (w * x) + (d getTaille * w)) @  (800 - (h + e * x + e)) . 	p3 := (100 + (w * x) + (d getTaille * w)) @  (800 - (h + e * x + h + e)) .	p4 := (100 + (w * x)) @  (800 - (h + e * x + h + e)) .	x := x+1.	m :=  (PolygonMorph			vertices: {p1. p2. p3. p4}			color: Color random			borderWidth: 1			borderColor: Color black).		piste addMorph: m.		d setMorph: m].Smalltalk at: #Piste put: piste'. "------------------------------------------"	 (jeu getEssenceAttribut: #disque) compile: 'piquetsCiblesPossibles   	| previous actual disques deplacements col |	deplacements := OrderedCollection new. 		" si je me suis déjà déplacé, sur quel piquet étais-je ? "	(self getEtat: #déplacé) notNil ifTrue: [previous := (self getEtat: #déplacé) getSituationDefinition].		actual := self getPiquet.				(((self getEtat: #sous) notNil or: [(self getEtat: #dernier) notNil]) ) ifFalse: [		(monde getSituations: #piquet) do: 			[:p |  (actual ~~ p and: [ p ~~ previous or: [p getTop isNil]]) ifTrue: [				disques :=  (p getElements select: [:each |    each getEssence getNom == #disque]) sorted: [:a :b | a getTaille > b getTaille].				((disques size == 0) and: [(self getEtat: #sur) notNil or: [self getNom == #disque_0] ])ifTrue: [deplacements add: p]. "p est libre et je ne libère pas mon piquet"				(disques size >  0) ifTrue:  [disques last getTaille >  self getTaille ifTrue: [deplacements add: p] ]]]].						"si un disque qui a déjà bougé occupe sa position finale, ne plus le bouger"						(actual getNom ~~ #piquet_0 and: [((actual getElements select: [:each |    each getEssence getNom == #disque]) at: 1) getNom == #disque_0]) 		ifTrue: [ ((self getNom  withoutPrefix: #disque_) asInteger ==(actual getNbDisques -1)) 						ifTrue: [deplacements removeAll]].								"	(''deplacements possibles pour '', self getNom asString, '' : '', deplacements asString ) crTrace.		"						^deplacements '.	 jeu compile: 'meilleurRelais	| z c s t w piquets disques meilleurDisque disqueLibere nbPiquetsLibres pg relaisPossibles ciblesPossibles meilleuresCibles meilleurRelais meilleureCible m pp libre step |		Transcript cr; show: ''----------------------------------------------------------------------''; cr.	"collection des disques pouvant se déplacer"	c := OrderedCollection new.	"pour chaque disque, association des piquets cibles possibles"	z := Dictionary new.	(monde get: #Hanoi) getEtres do: [ :d |		piquets := d piquetsCiblesPossibles.		piquets size > 0 ifTrue: [			c add: d.			z at: d put: piquets ] ].	c size == 0 ifTrue: [ ^nil ].		step := (Smalltalk at: #Step) + 1.	Smalltalk at: #Step put: step.	Transcript cr;  cr; show: ''step : '' , (Smalltalk at: #Step) asString; cr.			"	(monde get: #Hanoi) getDisques do: [:each |  (each getEtat: #déplacé) notNil ifTrue: [			Transcript cr; show: each getNom, '' déplacé de '', (each getEtat: #déplacé) getSituationDefinition getNom] ]."	relaisPossibles := OrderedCollection new.	c do: [ :d |		(z at: d) do: [ :p |			relaisPossibles add: (Association key: d value: p) ] ].	Transcript cr; cr; show: ''relaisPossibles : ''; cr.		relaisPossibles do: [ :ass |		Transcript show: ''           '' , ass asString; cr ].		"un seul disque qui peut se déplacer et une seule cible possible"	(c size == 1 and: [ (z at: (c at: 1)) size == 1 ]) ifTrue: [		meilleurRelais := relaisPossibles at: 1.		^ meilleurRelais ].		"un seul disque peut se déplacer avec plusieurs cibles possibles"			c size == 1 ifTrue: [meilleurDisque := c at: 1].					"deux disques peuvent se déplacer sur un ou deux piquets cibles" 		s := false.	(monde get: #Hanoi) getDisques size == 5 ifTrue: [		s := (Smalltalk at:#Step) == 3].	(monde get: #Hanoi) getDisques size == 6 ifTrue: [		s := (Smalltalk at:#Step) == 5].	(monde get: #Hanoi) getDisques size == 7 ifTrue: [		s := (Smalltalk at:#Step) == 5].	(monde get: #Hanoi) getDisques size == 8 ifTrue: [		s := (Smalltalk at:#Step) == 9].	(monde get: #Hanoi) getDisques size == 9 ifTrue: [		s := (((Smalltalk at:#Step) == 3 or: [(Smalltalk at:#Step) ==11]) or: [(Smalltalk at:#Step) == 13])].    		(monde get: #Hanoi) getDisques size == 10 ifTrue: [		s :=  ((((Smalltalk at:#Step) == 5 or: [(Smalltalk at:#Step) == 13]) or: [(Smalltalk at:#Step) == 17])   or: [(Smalltalk at:#Step) == 37])].		s ifTrue: [Transcript cr; show: ''+++ Le pus petit disque doit se déplacer'';  cr.		meilleurDisque := ((monde get: #Hanoi) getDisques sorted: [ :a :b | a getTaille < b getTaille ]) at: 1. "plus pett disque"].		meilleurDisque isNil ifTrue: [nbPiquetsLibres == 1 ifTrue: [c do: [ :each |  (each getEtat: #sur) isNil ifTrue: [meilleurDisque := each]]]].		meilleurDisque isNil ifTrue: [			meilleurDisque := ((monde get: #Hanoi) getDisques sorted: [ :a :b | a getTaille < b getTaille ]) at: 1. "plus pett disque"			c do: [ :each | each getTaille >= meilleurDisque getTaille ifTrue: [ meilleurDisque := each ]]].		Transcript cr;  show: ''meilleur disque : '' , meilleurDisque getNom asString; cr.	"recherche de la meilleure cible"		nbPiquetsLibres := ((monde getSituations: #piquet) select: [:ass | ass value  getTop isNil ]) size.	Transcript cr; show: ''nombre de piquets libres : '', ((monde getSituations: #piquet) select: [:ass | ass value  getTop isNil ]) size asString.		disqueLibere := nil.	(meilleurDisque getEtat: #sur) notNil ifTrue: [		disqueLibere := (meilleurDisque getEtat: #sur) getEtresAttributs at: 1 ].	ciblesPossibles := Dictionary new.	(z at: meilleurDisque) do: [ :p |		s := (monde get: #Hanoi) getDisques. "tous les disques"		"retirer de s le disque qui va se déplacer, car il sera dernier"		s remove: meilleurDisque.		"retirer, le cas échéant, le disque qui va être coiffé sur p "		disques := p getElements select: [ :each |			           each getEssence getNom == #disque ].		disques size > 0 ifTrue: [ s remove: (disques at: disques size) ].		"enlever de s tous les disques qui sont coiffés, sauf le disque éventuellement libéré"		t := OrderedCollection new copyWithAll: s.		s do: [ :each |			((each getEtat: #sous) notNil and: [ each ~~ disqueLibere ])				ifTrue: [ t remove: each ifAbsent: [  ] ] ].		"enlever de t le disque au top le plus grand si après déplacement tous les piquets sont occupés"		piquets := (monde getSituations: #piquet) copyWithout: p.		nbPiquetsLibres := (piquets select: [ :each | each getTop isNil ]) size.		(meilleurDisque getEtat: #sur) isNil ifTrue: [			nbPiquetsLibres := nbPiquetsLibres + 1 ].		"Transcript cr; cr;  show: ''nombre de piquets qui seront libres après déplacement de '', meilleurDisque getNom, '' vers '', p getNom, '' : '', nbPiquetsLibres asString."		pg := t at: 1.		t do: [ :each |			each getTaille > pg getTaille ifTrue: [ pg := each ] ].		nbPiquetsLibres == 0 ifTrue: [ t remove: pg ].		"Transcript cr; show: ''disques libres de se déplacer si '', meilleurDisque getNom asString, '' va vers '', p getNom asString, '' : '', t asString."		ciblesPossibles at: p put: t ].	Transcript cr; cr; show: ''ciblesPossibles pour '' , meilleurDisque getNom , '' : ''; cr.	ciblesPossibles associationsDo: [ :ass |	         Transcript show: ''           '' , ass asString; cr ].	"trouver le plus grand disque qui peut être libéré"	pg := ((monde get: #Hanoi) getDisques sorted: [ :a :b |		       a getTaille < b getTaille ]) at: 1. "disque le plus petit"	ciblesPossibles associationsDo: [ :ass |		ass value do: [ :each |			each getTaille > pg getTaille ifTrue: [ pg := each ] ] ].		Transcript cr; show: ''Plus grand disque qui peut être libéré : '' , pg getNom asString; cr.	"trouver les cibles laissant le plus grand disque libre"	meilleuresCibles := OrderedCollection new.		ciblesPossibles associationsDo: [ :ass |		(ass value includes: pg) ifTrue: [ meilleuresCibles add: ass ] ]. 		Transcript cr; show: ''cibles laissant '', pg getNom, '' libre de se déplacer : ''; cr.		meilleuresCibles do: [ :ass |		ass key getTop isNil ifTrue: [libre := '' libre''] ifFalse: [libre := ''''].		Transcript show: ''           '' , ass key asString, libre; cr ].		meilleuresCibles size = 1 ifTrue: [meilleureCible := (meilleuresCibles at: 1 ) key].	"Plusieurs cibles sont possibles, trouver  une cible qui est libre ou pour laquelle le top disque est le plus petit"	"	Transcript cr; show: ''taille du disque libéré : '', pg getTaille asString; cr.		 (monde getSituations: #piquet) do: [ :p | p getTop notNil ifTrue: [Transcript cr; show: ''taille du disque au sommet de '', p getNom, '' : '', p getTop getTaille asString]].	Transcript cr. "		"5 pour 7, 9 pour 8, 13 pour 9, 17 pour 10, 25 pour 11, ..."	((Smalltalk at: #Step) < 17 and: [meilleureCible isNil]) ifTrue: [		meilleuresCibles detect: [ :ass | ass key getTop isNil] ifFound: [:x |  meilleureCible := x key]]. 		meilleureCible isNil ifTrue: [		"Ne pas coiffer un disque qui peut recevoir le disque libéré"		piquets := (monde getSituations: #piquet) .		piquets detect: [:p | (p getTop notNil and: [p getTop getTaille == (pg getTaille + 2)]) ] ifFound: [:x | meilleuresCibles  detect: [:ass | ass key == x] ifFound: [:y | meilleuresCibles remove: y ifAbsent: [  ] ]]].		ciblesPossibles size ~~ meilleuresCibles size ifTrue: [Transcript cr; show: ''restriction des ciblesPossibles pour '' , meilleurDisque getNom , '' : ''; cr.		meilleuresCibles associationsDo: [ :ass |	         		Transcript show: ''           '' , ass asString; cr ]].		meilleureCible isNil ifTrue: [		"disque_0"		pp := ((monde get: #Hanoi) getDisques sorted: [ :a :b |			       a getTaille > b getTaille ]) at: 1.		m := meilleuresCibles at: 1.				meilleuresCibles do: [ :ass |			(ass key getTop notNil and:[				ass key getTop getTaille <=  pp getTaille]) ifTrue: [ 				pp := ass key getTop.				m :=  ass]].	meilleureCible := m key].	Transcript cr; cr; show: ''meilleure cible pour '' , meilleurDisque getNom asString, '' : '', meilleureCible getNom asString; cr.	meilleurRelais := Association key: meilleurDisque value: meilleureCible.	^ meilleurRelais'.		(jeu getEssenceAttribut: #disque) compile: 'prendLeRelais: cible						Smalltalk at: #go put: false.			[Smalltalk at: #go] whileFalse: [Semaphore new				waitTimeoutMilliseconds: (Smalltalk at: #delay)				onCompletion: [  ]				onTimeout: [  ]]. 						(monde get: #Hanoi) getDisques  do: [ :d | d removeEtatDeNom: #dernier ].	self affecteEtat: (absolu get: #dernier) dansSituation: monde.		(Smalltalk at: #StepMorph) contents: (Smalltalk at: #Step) asString. 		self vaSurPiquet: cible '.	(jeu getEssenceAttribut: #disque) compile: 'vaSurPiquet: unPiquet	| d dd p x y w h e g1 g2 g3  g4 z c  |	w := 10.	h := 16.	e :=5.	z := (monde get: #Hanoi) getDisques first getTaille * w.	g1 := 100 + (z / 2).	g2 := 100 + (3 * z / 2).	g3 := 100 + (5 * z / 2).	g4 := 100 + (7 * z / 2).		p := self getPiquet.		(''>> '', self getNom asString , '' : '' , p getNom , '' ---> '' , unPiquet getNom) crTrace.		"disques sur mon piquet "	d := (p getElements select: [ :each |		     each getEssence getNom == #disque ]) sorted: [:a :b | a getTaille > b getTaille]. 	"disques sur  piquet cible "	dd := (unPiquet getElements select: [ :each |		      each getEssence getNom == #disque ]) sorted: [:a :b | a getTaille > b getTaille]. 		(dd size == 0 or: [ dd last getTaille > self getTaille ]) ifTrue: [ "je quitte mon piquet "		p removeEtre: self.		d := (p getElements select: [ :each |			     each getEssence getNom == #disque ]) sorted: [:a :b | a getTaille > b getTaille]. "disques restant sur mon piquet"		d size ~~ 0 ifTrue: [			d last removeEtatDeNom: #sous.			self removeEtatDeNom: #sur ].		(self getEtat: #déplacé) isNil ifFalse: [self removeEtatDeNom: #déplacé].		(self affecteEtat: (piquet get: #déplacé) dansSituation: p)].	dd size ~~ 0 ifTrue: [		(dd last affecteEtat: (absolu get: #sous) dansSituation: monde)			attributionEtre: self.		(self affecteEtat: (absolu get: #sur) dansSituation: monde)			attributionEtre: dd last ].	unPiquet introductionEtre: self.  	"	((monde get: #Hanoi) getDisques  copyWithout: self)  do:  [ :d | (d getEtat: #déplacé) notNil  ifTrue: [d removeEtatDeNom: #déplacé]]. "	"	((monde get: #Hanoi) getDisques  copyWithout: self)  do:  [ :d | ((d getEtat: #déplacé) notNil and: [(d getEtat: #déplacé) getSituationDefinition == p]) ifTrue: [d removeEtatDeNom: #déplacé]].  ""	((monde get: #Hanoi) getDisques  copyWithout: self)  do:  [ :d | ((d getEtat: #déplacé) notNil and: [(d getEtat: #déplacé) getSituationDefinition == unPiquet]) ifTrue: [d removeEtatDeNom: #déplacé]].  "		unPiquet getNom == #piquet_0 ifTrue: [		x := g1 - (self getTaille * w / 2)].		unPiquet getNom == #piquet_1 ifTrue: [		x := g2 - (self getTaille * w / 2)].		unPiquet getNom == #piquet_2 ifTrue: [		x := g3 - (self getTaille * w / 2)].		unPiquet getNom == #piquet_3 ifTrue: [		x := g4 - (self getTaille * w / 2)].	y := 800  - ((dd size +1) * (h + e)) .		self getMorph position: x @ y .	"Semaphore new		waitTimeoutMilliseconds: (Smalltalk at: #delay)		onCompletion: [  ]		onTimeout: [  ].""	Smalltalk at: #go put: false.	[Smalltalk at: #go] whileFalse: [Semaphore new		waitTimeoutMilliseconds: (Smalltalk at: #delay)		onCompletion: [  ]		onTimeout: [  ]]"	 '.			"-------------------------------------------"			iceo soit: #Hanoi essence: jeu." empilement intial des disques sur le piquet 0"(monde get: #Hanoi) getDisques  do: 			[:d | (monde getSituation:  #piquet_0)  introductionEtre: d].(Interval from: 1 to: ((monde get: #Hanoi) getDisques size -1))  do:  [:i | 				((monde get: #Hanoi) getDisques at:  i)  affecteEtat: (absolu get: #sous) dansSituation:  monde. 				(((monde get: #Hanoi) getDisques at:  i)  getEtat: #sous) attributionEtre:  ((monde get: #Hanoi) getDisques at:  i+1).				((monde get: #Hanoi) getDisques at:  i+1)  affecteEtat: (absolu get: #sur) dansSituation:  monde. 				(((monde get: #Hanoi) getDisques at:  i+1)  getEtat: #sur) attributionEtre:  ((monde get: #Hanoi) getDisques at:  i)].			" définition du rôle de chaque joueur "  (monde get: #Hanoi) getEtres do: [ :each |	| started |	started := false.	(each getEtat: #comportement) setSemaphore: Semaphore new.	(each getEtat: #comportement) setProcess: ([:h  :d |		 | s x  |		 s isNil ifTrue: [ s := false ].		 [ true ] whileTrue: [			 s ifFalse: [				 s := true.				 (d getEtat: #comportement) getSemaphore wait ].						x := h meilleurRelais. 			x notNil ifTrue: [				x key prendLeRelais: x value.				(x key getEtat: #comportement) getSemaphore signal].					 (d getEtat: #comportement) getSemaphore wait ] ] newProcessWith:  (Array with: (monde get: #Hanoi) with: each)) ].												" ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- "									Transcript clear.Smalltalk at: #Step put: 0.(monde get: #Hanoi)  allezAuxStartingBlocks.