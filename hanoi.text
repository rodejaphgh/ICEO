" WorldMorph currentWorld "PolygonMorph subclass: #ICEOMorph	instanceVariableNames: ''	classVariableNames: ''	package: 'Morphic-Base-Basic'.	ICEOMorph compile: 'handlesMouseDown: anEvent       ^ true'.ICEOMorph compile: 'mouseDown: anEvent    anEvent redButtonPressed        ifTrue: [((Smalltalk at: #Step) == 0) ifTrue: [Smalltalk at: #Step put: 0.   (monde get: #Hanoi)  go]].      anEvent yellowButtonPressed     ifTrue: [(monde get: #Hanoi) fin. ICEO reset. ''See you soon !'' crTrace].self changed'.iceo definition: #jeu.iceo definitionSituation: #piquet.jeu referenceEssence: piquet cardinalite: 3.          iceo definitionAttribut: #disque de: jeu cardinalite: 6.jeu compile: 'nbDisques 	^self getEtres size'.iceo definitionQualite: #sous situation: absolu.(absolu get: #sous) referenceEssence: (jeu getEssenceAttribut: #disque).(jeu getEssenceAttribut: #disque) peutEtre: (absolu get: #sous).iceo definitionQualite: #sur situation: absolu.(absolu get: #sur) referenceEssence: (jeu getEssenceAttribut: #disque).(jeu getEssenceAttribut: #disque) peutEtre: (absolu get: #sur).iceo definitionQualite: #déplacé situation: absolu.(absolu get: #déplacé) referenceEssence: (jeu getEssenceAttribut: #piquet).(jeu getEssenceAttribut: #disque) peutEtre: (absolu get: #déplacé).iceo definitionQualite: #dernier situation: absolu.(jeu getEssenceAttribut: #disque) peutEtre: (absolu get: #dernier).jeu compile: 'allezAuxStartingBlocks	self getEtres do: [:each |  (each getEtat: #comportement) getProcess resume].	self construirePiste.	(Smalltalk at: #Piste)  openInWorld '.	" le disque le plus petit commence "jeu compile: 'go	((((self getEtresAttributs: #disque)  sorted: [:a :b |   a getTaille <  b getTaille]) at: 1)  getEtat: #comportement)  getSemaphore  signal'.	jeu compile: 'fin	self getEtres do: [:each |  (each getEtat: #comportement) getProcess terminate].	(Smalltalk at: #Piste) delete'.iceo definitionQualiteEssentielle: #comportement pour: (jeu getEssenceAttribut: #disque) effectivite: #permanente.( (jeu getEssenceAttribut: #disque) getQualite: #comportement) addInstVarNamed: #sem.( (jeu getEssenceAttribut: #disque) getQualite: #comportement) compile: 'setSemaphore: unSemaphore sem := unSemaphore'. ( (jeu getEssenceAttribut: #disque) getQualite: #comportement) compile: 'getSemaphore ^sem'. ( (jeu getEssenceAttribut: #disque) getQualite: #comportement) addInstVarNamed: #process.( (jeu getEssenceAttribut: #disque) getQualite: #comportement) compile: 'setProcess: unProcess process := unProcess'. ( (jeu getEssenceAttribut: #disque) getQualite: #comportement) compile: 'getProcess ^process'." pour l'animation "(jeu getEssenceAttribut: #disque) addInstVarNamed: #morph.(jeu getEssenceAttribut: #disque)  compile: 'setMorph: uneMorph morph := uneMorph'. (jeu getEssenceAttribut: #disque)  compile: 'getMorph ^ morph'. (jeu getEssenceAttribut: #disque) compile: 'getTaille	^((monde get: #Hanoi) getEtresAttributs: #disque) size - (self getNom  withoutPrefix: #disque_) asInteger'.	(jeu getEssenceAttribut: #disque) compile: 'getPiquet	^((monde get: #Hanoi) getEtresAttributs: #piquet) detect: [:each |  each getElements includes: self]'.	 (jeu getEssenceAttribut: #disque) compile: 'peutSeDeplacer	| disques |	((self getEtat: #sous) notNil or: [(self getEtat: #dernier) notNil]) ifTrue: [^false].  	((monde get: #Hanoi) getEtresAttributs: #piquet) do: 		[:p | disques :=  p getElements select: [:each |    each getEssence getNom == #disque]. 			(disques size == 0 or: [disques last getTaille >  self getTaille])  ifTrue: [^true]].	^false '.	jeu  compile: 'construirePiste| piste m p1 p2 p3 p4 x |piste  := (ICEOMorph		vertices: {500@400. 1130@400. 1130@600. 500@600}		color: Color lightBlue		borderWidth: 1		borderColor: Color black).Smalltalk at: #StepMorph put: (((StringMorph contents: ''0'') position: (510@410)) color: Color black).piste addMorph: (Smalltalk at: #StepMorph).(((monde get: #Hanoi)  getEtreAttribut: #piquet_0) getElements select: [:each |  each getEssence getNom == #disque]) do: [:d |   	x :=  (monde get: #Hanoi) nbDisques .		p1 := (600 - (((400/x)  +  (16 * (d getTaille -1))) / 2)) rounded  @    (575 - ((x - (d getTaille -1)  -1)  * 25)).       	p2 := (600 + (((400/x)  +  (16 * (d getTaille -1))) / 2)) rounded @  (575 - ((x - (d getTaille -1)  -1)  * 25)).	p3 := (600 + (((400/x)  +  (16 * (d getTaille -1))) / 2)) rounded @ (590 - ((x - (d getTaille -1)  -1)  * 25)).	p4 := (600 - (((400/x)  +  (16 * (d getTaille -1))) / 2))rounded  @ (590 - ((x - (d getTaille -1)  -1)  * 25)).			m :=  (PolygonMorph			vertices: {p1. p2. p3. p4}			color: Color random			borderWidth: 1			borderColor: Color black).		piste addMorph: m.		d setMorph: m].Smalltalk at: #Piste put: piste'. (jeu getEssenceAttribut: #disque) compile: 'vaSurPiquet: unPiquet	| d dd p x y |	p := self getPiquet.	d := p getElements select: [ :each |		     each getEssence getNom == #disque ]. "disques sur mon piquet "	dd := unPiquet getElements select: [ :each |		      each getEssence getNom == #disque ]. "disques sur  piquet cible "	(dd size == 0 or: [ dd last getTaille > self getTaille ]) ifTrue: [ "je quitte mon piquet "		p removeEtre: self.		d := p getElements select: [ :each |			     each getEssence getNom == #disque ]. "disques restant sur mon piquet"		d size ~~ 0 ifTrue: [			d last removeEtatDeNom: #sous.			self removeEtatDeNom: #sur ].		self removeEtatDeNom: #déplacé.		(self affecteEtat: (absolu get: #déplacé) dansSituation: monde)			attributionEtre: p ].	dd size ~~ 0 ifTrue: [		(dd last affecteEtat: (absolu get: #sous) dansSituation: monde)			attributionEtre: self.		(self affecteEtat: (absolu get: #sur) dansSituation: monde)			attributionEtre: dd last ].	unPiquet introductionEtre: self.	(self getNom asString , '' : '' , p getNom , '' ---> '' , unPiquet getNom)		crTrace.	unPiquet getNom == #piquet_0 ifTrue: [		x := 600 - (80 + (16 * (self getTaille - 1)) / 2) ].	unPiquet getNom == #piquet_1 ifTrue: [		x := 600 - (80 + (16 * (self getTaille - 1)) / 2) + 200 ].	unPiquet getNom == #piquet_2 ifTrue: [		x := 600 - (80 + (16 * (self getTaille - 1)) / 2) + 400 ].	y := 590 - (unPiquet getElements size * 26).	self getMorph position: x rounded @ y.	Semaphore new		wait: (Duration milliSeconds: 100)		onCompletion: [  ]		onTimeout: [  ] '.(jeu getEssenceAttribut: #disque) compile: 'sprint	| disques disks choix step previous |	choix := nil.	disques := self getPiquet getElements select: [ :each |		           each getEssence getNom == #disque ].	" si un disque en dessous, chercher le premier piquet libre "	previous := self getEtat: #déplacé.	(self getEtat: #sur) notNil ifTrue: [		((monde get: #Hanoi) getEtresAttributs: #piquet) do: [ :unPiquet |			disks := unPiquet getElements select: [ :each |				         each getEssence getNom == #disque ].			disks size == 0 ifTrue: [				previous isNil					ifTrue: [ choix isNil ifTrue: [ choix := unPiquet ] ]					ifFalse: [						unPiquet ~~ (previous getEtreAttribut: #piquet) ifTrue: [							choix isNil ifTrue: [ choix := unPiquet ] ] ] ] ] ].	choix isNil ifTrue: [		disks := OrderedCollection new.		((monde get: #Hanoi) getEtresAttributs: #piquet) do: [ :p |			disques := p getElements select: [ :each |				           each getEssence getNom == #disque ].			disks := disks , (disques select: [ :d | d getTaille > self getTaille ]) ].		disks size > 0 ifTrue: [			previous notNil				ifTrue: [					choix := (disks detect: [ :d |						          d getPiquet ~~ (previous getEtreAttribut: #piquet)							          and: [ self getPiquet ~~ d getPiquet ] ]) getPiquet ]				ifFalse: [					choix := (disks detect: [ :d | self getPiquet ~~ d getPiquet ])						         getPiquet ] ] ].	choix isNil ifTrue: [		((monde get: #Hanoi) getEtresAttributs: #piquet) reverseDo: [			:unPiquet |			disques := unPiquet getElements select: [ :each |				           each getEssence getNom == #disque ].			(disques size == 0 or: [ disques last getTaille > self getTaille ])				ifTrue: [ choix isNil ifTrue: [ choix := unPiquet ] ] ] ].	self vaSurPiquet: choix.	(monde get: #Hanoi) getEtres do: [ :d | d removeEtatDeNom: #dernier ].	self affecteEtat: (absolu get: #dernier) dansSituation: monde.	step := (Smalltalk at: #Step) + 1.	Smalltalk at: #Step put: step.	(Smalltalk at: #StepMorph) contents: step asString'.						iceo soit: #Hanoi essence: jeu." situation  intiale des disques sur le piquet piquet_0"((monde get: #Hanoi) getEtresAttributs: #disque)  do: 			[:d | ((monde get: #Hanoi) getEtreAttribut: #piquet_0)  introductionEtre: d].		" état intial des disques "(Interval from: 1 to: (((monde get: #Hanoi) getEtresAttributs: #disque) size -1))  do: 			[:i | 				(((monde get: #Hanoi) getEtresAttributs: #disque) at:  i)  affecteEtat: (absolu get: #sous) dansSituation:  monde. 				((((monde get: #Hanoi) getEtresAttributs: #disque) at:  i)  getEtat: #sous) attributionEtre: 	(((monde get: #Hanoi) getEtresAttributs: #disque) at:  i+1).				(((monde get: #Hanoi) getEtresAttributs: #disque) at:  i+1)  affecteEtat: (absolu get: #sur) dansSituation:  monde. 				((((monde get: #Hanoi) getEtresAttributs: #disque) at:  i+1)  getEtat: #sur) attributionEtre:  (((monde get: #Hanoi) getEtresAttributs: #disque) at:  i)].			" déclaration des joueurs "	(monde get: #Hanoi) getEtres do: [ :each |		| choix started |		started := false.		(each getEtat: #comportement) setSemaphore: Semaphore new.		(each getEtat: #comportement) setProcess: ([ :h :d |			 | s |			 s isNil ifTrue: [ s := false ].			 [ true ] whileTrue: [				 s ifFalse: [					 (d getNom , ' is ready') crTrace.					 s := true.					 (d getEtat: #comportement) getSemaphore wait ].				 " qui peut se déplacer ? "				 choix := h getEtres detect: [ :disque | disque peutSeDeplacer ].				 choix == d					 ifTrue: [ "c'est moi"						 d sprint.						 "qui peut maintenant se déplacer en dehors de moi ? "						 h getEtres							 detect: [ :disque | disque peutSeDeplacer ]							 ifFound: [ :x |							 (x getEtat: #comportement) getSemaphore signal ].						 (d getEtat: #comportement) getSemaphore wait ]					 ifFalse: [ "ce n'est pas moi"						 (choix getEtat: #comportement) getSemaphore signal.						 (d getNom , ' is waiting') crTrace.						 ' ' crTrace.						 (d getEtat: #comportement) getSemaphore wait ] ] ]				 newProcessWith: (Array with: (monde get: #Hanoi) with: each)) ].						" ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- "											Transcript clear.Smalltalk at: #Step put: 0.(monde get: #Hanoi)  allezAuxStartingBlocks.